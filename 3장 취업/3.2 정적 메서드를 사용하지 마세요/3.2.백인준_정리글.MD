# 간략한 내용 정리

- 정적메소드를 사용하는 대신 객체를 사용
  - 정적메소드는 새로 객체를 생성할 필요가 없고 사용성 측면에서도 매우 직관적이지만 
  유지보수하기 어렵게 만든다. 이유는 아래에서 설명

## 객체 대 컴퓨터 사고 
- 순차적인 사고방식은 규모가 커지면 한계에 부딪힌다.
- 객체지향 프로그래밍이 절차적 프로그래밍과 차별화되는 점은 'is a'이다.
  - 우리는 컴퓨터에게 시키는것이 아니라 필요한 기능이 있으면 정의하는것.
- 정적메소드는 객체지향 언어의 문법을 사용하면서 절차적 사고를 하도록 부추긴다.

## 선언형 스타일 대 명령형 스타일 
- 명령형 -> 프로그래밍의 상태를 변경하는 문장을 사용하여 계산방식 서술
  - 메서드가 호출하는 즉시 결과를 반환 

- 선언형 -> 제어흐름을 서술하지않고 계산로직을 표현 엔티티와 엔티티간의 관계로 구성하는 자연스러운 사고 패러다임
  - 무엇인지만 정의하고 사용자가 값을 계산하는 시점에 결정 


차이점

- 선언형이 명령형보다 빠르다.
    - 우리가 직접 성능 최적화 가능
    - 하나의 메서들 호출하는거면 정적메소드가 빠르지만 여러개의 라면 선언형이 훨씬 빠르다.
    - 컴퓨터에게 시점과 위치를 결정하도록 위임
    - 실행관점에서 더최적화 되기 떄문
- 다형성
  - 모두 클래스 이기때문에 유연하게 다른 알고리즘과 조합 가능
  - 정적메소드는 생성자의 인자로 객체를 전달 불가
- 표현력
  - 정적메소드는 결과를 반환하는것을 생각하고 표현
  - 선언형은 보다 영어에 가깝게 표현가능 
  - 알고리즘과 실행 대신 객체와 행동에 관해 생각하면 좀더 올바른 생각가능 
- 응집도
  - 계산을 책임지는 코드가 한곳에 뭉쳐있기 떄문에 분리하기 힘들고 실수로 코드의 순서를 변경하면
  알고리즘의 문제가 발생할 여지가 많다.
  - 선언형은 변경이 용이하고 시간적 결합을 줄일수있다.

## 유틸리티 클래스
- 정적메서드 들을 모아놓은 컬랙션
- 인스턴스를 생성못하게 하기위해 private 생성자(빈공간) 를 생성
- 분리할수 없는 하듵코딩의 의존성

## 싱글톤 패턴
- 이책에서 기술하기에 유틸리티 클래스보다는 낫지만 끔찍한 안티패턴이다.
- 싱글톤은 getInstance()와 함께 setInstance()를 추가 할수있다.
  - 내부에 캡술화된 정적객체를 교체할수있다.
  - OOP에는 전역범위가 없다. 하지만 싱글톤은 전역변수 그이상 그이하도 아니다.

##함수형 프로그래밍
- 함수형은 오직 함수만 사용가능 하지만 OOP는 객체와 메서드 조합이 가능 하다.

##조합가능한 데코레이터
- 내부 캡슐화하고 있는 객체에 별도의 행동을 추가 (AOP,@NonNull)

#읽고 느낀점
- 이책에서 읽은 바로는 너무 정적메소드들을 악이라고 표현하고 있습니다.
- 이전 이펙티브 자바나 제가활용했던 정적팩토리 메소드들은 어떻게 할지 생각이 든다.
- 하지만 객체를 사용하는것이 훨씬 유연할것이라는 것은 저도 동감 왜냐하면 정적팩토리 메소드는
어떤것을 추가하거나 새로운것과 조합해서 사용할수가 없기때문
- 유틸리티 클래스는 회사에서 많이 사용하고 있는데 이것도 좀더 유연하게 클래스 메서드 객체를 사용하면
좀더 편하게 바꿀수있지않을까?
- 싱글톤은 이해못하겠습니다. 지금까지 코딩하면서 안티패턴이라고 생각을 못했기떄문이고 전역변수를 쓰지말아야하는것은 알고있지만
디비 연결 같은 것들은 싱글톤으로 전역으로 한번만 호출하고 사용할수 있도록 하는게 편하지않을까요?
아직 연습이 덜되어서 그런지 이부분은 다른방식 으로 객체상태로 잘관리 할수있을지 의문입니다.
