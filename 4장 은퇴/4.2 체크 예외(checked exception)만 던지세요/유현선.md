# 4.2 체크 예외(checked exception)만 던지세요
> 작성자 : 유현선

언체크 예외를 사용하는 것은 실수이며, 모든 예외는 체크 예외 이어야한다. (Java 는 두 종류의 예외를 모두 제공)
또한 다양한 예외 타입을 만드는 것도 좋지 않은 생각이다.  

```java
class ExceptionTest {
    public int length(File file) {
        try {
            return content(file).length();
        } catch (IOException ex) {
            // 이 예외에 대해 어떤 처리를 해야 하며
            // 바로 여기에서 예외를 해결하거나
            // 더 상위 레벨로 전달해야 한다.
        }
    }
}
```
- 체크 예외
  - 가시적(visible)
  - 해롭고 안전하지 않은 메서드를 다루고 있다는 사실을 기억하고, 안전하지 않다고 선언하고나, 예외를 잡아서 해결해야 함

- 언체크 예외
  - 예외의 타입을 선언하지 않아도 무방 
  - 호출하는 쪽에서는 어떤 예외가 던져질 지 예상할 수 없다


## 꼭 필요한 경우가 아니라면 예외를 잡지 마세요
- 메서드를 설계할 때 예외를 더 높은 레벨로 전파하자
- 모든 catch 문에는 납득할 수 있는 이유가 있어야한다. = 반드시 예외를 잡아야하는 이유가 있거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡아서는 안된다.
- 끔찍한 안티패턴 : 잡아서 로깅하기, 흐름 제어를 위한 예외 사용 

## 항상 예외를 체이닝하세요: 예외 되던지기
```java
class GoodPracticeRethrowing() {
    public int length(File file) throws Exception {
        try {
            return content(file).length();
        } catch (IOException ex) {
            throw new Exception("길이를 계산할 수 없다.", ex);
            /*
             * - 원래의 문제를 새로운 문제로 대체함으로써 문제가 발생했다는 사실을 무시하지 않음
             * - 대신 원래의 문제를 새로운 문제로 감싸서 함게 상위로 던짐 
             * 
             * => 문제를 발생시켰던 낮은 수준의 근본 원인을 소프트웨어의 더 높은 수준으로 이동시킴
             * */
        }
    }
}
```
- 항상 예외를 체이닝하고 절대로 원래 예외를 무시하지 말 것
- 각각의 메서드는 발생할 수 있는 모든 예외를 잡은 후, 예외를 체이닝해서 다시 전져야 함


## 단 한번만 복구하세요
```java
public class App {
    public static void main(String[] args) {
        try {
            System.out.println(new App().run());
        } catch (Exception ex) {
            System.err.println("문제 발생 : " + ex.getLocalizedMessage());
            
            // 복구하기에 적합한 유일한 장소.
        }
    }
}
```
- 소프트웨어에서 복구에 적합한 몇개의 장소를 찾아서
- 그 외의 장소에선 항상 예외를 잡고, 체이닝하고, 다시 던진 뒤
- 가장 최상위 수준에서 오직 한번만 복구해라


## 관점-지향 프로그래밍을 사용하세요
실패 재시도는 OOP 의 코드를 깔끔한 상태로 유지하기 위해 AOP 를 적용할 수 있는 현실적이면서도 실용적인 예외이다.


## 하나의 예외 타입만으로도 충분합니다
- 절대 복구하지 않기(단 한번만 복구하기) + 항상 체이닝하기 => 하나의 예외 타입만으로 충분하다.
