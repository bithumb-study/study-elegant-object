# 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요

이 내용은 `엘레강트 오브젝트` 를 읽으면서 정리한 내용을 포함하고 있습니다.

- 페이크(Fake)
- 한걸음 더 나아가기
- 정리

## 페이크(Fake)

테스트를 최적화하기 위한 도구인 모킹(Mocking)이 있습니다.
하지만 모킹 대신 페이크 객체를 사용할 것을 제안합니다.

- 페이크 클래스는 인터페이스의 일부이며 인터페이스와 함께 제공
- 페이크 클래스가 실제 클래스보다 더 복잡한 경우도 존재
- 페이크 클래스를 만족하도록 테스트를 작성하지 말고, 페이크 클래스가 테스트를 올바르게 지원하도록 작성

프로덕션 코드가 변경되면 단위 테스트가 실패하기 때문에, 단위 테스트는 코드 리팩토링에 큰 도움이 됩니다.
하지만 동시에 프로덕션 코드가 변경되지 않을 경우에는 실패해서는 안됩니다.

페이크 클래스가 존재하는 상황에서 해당 인터페이스를 변경하기 위해서는 자연스럽게 해당 인터페이스 클래스의 구현도 함께 변경해야 합니다.
페이크 클래스를 사용하면 테스트를 충분히 유지보수 가능하게 만들 수 있습니다.

### 실습해보기

외부 Queue의 메세지를 보내는 서비스 메소드를 테스트 한다고 가정해봅시다.

![서비스코드](../../../참고/6week/1.png)

- 메세지를 보내고 실패가 나면 RuntimeException으로 감싸는 것이 잘 수행되는지를 테스트 하고 싶습니다.

기존처럼 `@Mock` 을 통해 테스트 코드를 짜면 아래와 같이 됩니다.

![Mock_단위테스트코드](../../../참고/6week/2.png)

- 보시는 것처럼 엄청 간단하게 작성됩니다.
- 엄청 간단하게 작성된 것이 중요합니다.
- 대상 객체인 CustomerService가 테스트 하기 어려울 정도로 의존성이 결합되어 있지만 아주 간단하게 테스트 코드가 작성된 것입니다.

`@Mock` 이 없이 테스트 코드를 작성한다면 어떻게 될까요?

![Mock없이_단위테스트코드](../../../참고/6week/3.png)

- Mocking 해야할 대상이 너무 많습니다.
- CustomerService가 의존하고 있는 모든 Bean 들의 MockClass 생성이 필요해서 테스트 코드 작성하기가 정말 힘듭니다.

그럼 테스트 하기 좋은 코드로 될려면 어떻게 바꿔야할까요?
테스트 대상인 sendMessage 메소드가 의존하고 있는 의존성은 RabbitTemplate 뿐입니다.
그래서 Queue 에 메세지를 보내는 sendMessage를 별도의 컴포넌트로 분리하면 됩니다.

![Mock없이_단위테스트코드](../../../참고/6week/4.png)

 그 후에는 테스트 코드 작성하기가 굉장히 쉬워집니다. 분리된 해당 클래스만 테스트 하면 되기 때문입니다.

 ![Mock없이_단위테스트코드](../../../참고/6week/5.png)

 ## 한걸음 더 나아가기

 Mock만 사용하지 않는다고 해결이 되는 것은 아닙니다.
 테스트 코드를 작성하면서 가장 염려해야될 부분이 프로덕션 코드와 테스트 코드가 같이 움직이지 않는 것입니다. 그러기 때문에 프로덕션 코드의 내용이 변경된다면 테스트는 실패하게 됩니다.
 
그래서 해당 챕터에서는 Fake 클래스에 대해서 제안하고 있습니다.
아래와 같이 기존에 구현한 클래스의 인터페이스를 추가하고 Fake inner 클래스를 생성하도록 하겠습니다.

![Mock없이_단위테스트코드](../../../참고/6week/6.png)

- 프로덕션 코드가 변경된다면 컴파일 에러를 통해서 같이 수정이 일어나게 됩니다.
- 프로덕션 코드와 테스트 코드가 같이 움직입니다.

![Mock없이_단위테스트코드](../../../참고/6week/7.png)

## 정리

- 페이크 클래스가 존재하는 상황에서 해당 인터페이스를 변경하기 위해서는 자연스럽게 해당 인터페이스 클래스의 구현도 함께 변경해야 합니다.
- 페이크 클래스를 사용하면 테스트를 충분히 유지보수 가능하게 만들 수 있습니다.